<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Harness 的力量：四种 Agent 驾舱的深度解剖</title>
  <meta name="description" content="拆解 Claude Code、LangGraph、AutoGen、ReAct+Function Calling 四种典型 harness，讨论为什么“驾舱”决定了一半的智能体验。" />
  <link rel="stylesheet" href="/post.css" />
</head>
<body>
  <main class="wrap">
    <div class="top mono"><a href="/">← home</a></div>
    <h1>Harness 的力量：四种 Agent 驾舱的深度解剖</h1>
    <p class="lead">20 分钟长文，聊清楚为什么同一个模型接在不同 harness 下，会像换了大脑。</p>
    <div class="meta mono">Published: 2026 · agent systems · ~20 min read</div>

    <div class="sep"></div>

    <h2>为什么要花整篇文章讨论 harness？</h2>
    <p>当我们说“模型今天又犯傻”时，往往骂错了对象。大多数时候真正的问题出在 <em>harness</em>——也就是承载模型的那一层：它如何布置上下文、如何给出工具权限、如何回收状态、如何在失败时兜底。一个好的 harness 让模型像接上战斗机的座舱；一个糟糕的 harness 则像把飞行员丢进没有仪表盘的仓库。Claude Agent SDK 里那句“Claude Code is the best harness”绝非夸张，它强调的是：<strong>智能体验的上限，取决于你给模型的驾舱。</strong></p>

    <p>这篇文章挑了四种代表性 harness：<strong>Claude Code</strong>、<strong>LangGraph / LangChain Agents</strong>、<strong>AutoGen</strong>、<strong>OpenAI Function Calling + ReAct</strong>。每一种都解决了不同的痛点，也有自己的护城河与盲区。下文会依次拆解它们的架构、适用场景、踩坑经验，并给出一份“如何挑选/构建 harness”清单。</p>

    <h2>Harness 到底是什么？</h2>
    <p>我更喜欢把 harness 翻译成“驾舱”或“挂架”：它是一层在模型与现实世界之间的粘合剂，负责七件事：</p>
    <ol>
      <li><strong>提示编排</strong>：把系统提示、用户输入、上下文记忆组合成模型理解的格式。</li>
      <li><strong>工具目录</strong>：定义允许调用的命令/API，并帮模型处理参数、执行与回显。</li>
      <li><strong>状态管理</strong>：记录已执行的动作、文件改动、外部响应，为下一轮提供记忆。</li>
      <li><strong>安全限制</strong>：审计危险命令、沙箱执行、限速，避免模型误删生产数据。</li>
      <li><strong>错误恢复</strong>：统一处理异常，提供可重试的上下文，而不是让会话直接崩溃。</li>
      <li><strong>进度可视化</strong>：在日志、界面或聊天窗口里同步每次动作，方便人类跟进。</li>
      <li><strong>多模协同</strong>：当需要多个角色/模型协作时，负责传递消息、决定轮次与终止条件。</li>
    </ol>
    <p>如果这些工作你都交给模型“自己解决”，它就会把 tokens 消耗在搭积木上，而不是在核心任务上。一个成熟 harness 让模型 <em>只思考</em>，不必 <em>自己造工具</em>。</p>

    <h2>Claude Code：工程化最彻底的单兵座舱</h2>
    <p>Claude Code 是 Claude Agent SDK 里默认的编程 harness。它的核心优势在于：<strong>工程化的一致性</strong>。每个会话都遵循相同的目录结构、相同的工具权限和同一套系统提示，这让 Claude 在代码编辑、调试、文件管理上高度可靠。</p>
    <h3>1. 结构设计</h3>
    <ul>
      <li><strong>文件沙箱</strong>：每个 session 都有独立工作目录，所有编辑/生成的文件都能被追踪。</li>
      <li><strong>命令调度</strong>：通过 <code>bash</code>、<code>python</code>、<code>ls/cat</code> 等受控命令执行环境，Claude 只需发出意图，harness 自动执行。</li>
      <li><strong>日志回放</strong>：系统把每条命令及 stdout/stderr 结构化记录，并作为下一轮的上下文提供给模型。</li>
      <li><strong>工具描述</strong>：Claude 通过提示熟悉“我能做什么、不能做什么”，减少了冗余问答。</li>
    </ul>
    <h3>2. 为什么它像“最佳 harness”</h3>
    <ol>
      <li><strong>开箱稳定</strong>：不需要自己搭脚手架就能获得完整的工程工作流。</li>
      <li><strong>思考资源集中</strong>：Claude 把 tokens 用在推理和代码本身，而不是“如何运行命令”。</li>
      <li><strong>易于扩展</strong>：可以在现有提示里声明新的脚本/工具，比如部署脚本或外部 API。</li>
    </ol>
    <h3>3. 适用场景</h3>
    <ul>
      <li>需要频繁读写文件的任务：代码修复、配置调整、批量重构。</li>
      <li>希望最少自定义、最快上线的个人工程师。</li>
      <li>强调可审计性的团队：每一步动作都有日志，方便回溯。</li>
    </ul>
    <h3>4. 局限</h3>
    <p>Claude Code 的默认套件主要面向单人单模型工作流。若需要多代理协作、复杂状态机或跨仓库 orchestration，仍需在它之上再包一层。它也更偏工程任务，对对话式知识库、超大上下文追踪等需求，需要额外组件。</p>

    <h2>LangGraph / LangChain Agents：把工作流画成图</h2>
    <p>LangChain 在 2023 年大火后，很多人只把它当“prompt 拼装器”。但它真正的杀手锏是 LangGraph：一种用有向图描述 Agent 流程的 harness。你可以把复杂任务拆成多个节点：检索节点、决策节点、工具节点、总结节点……由图控制调用顺序与循环条件。</p>
    <h3>1. 核心机制</h3>
    <ul>
      <li><strong>图式思维</strong>：每个节点可以是一个模型调用、一个函数、或一段自定义逻辑。边界条件决定下一步去哪。</li>
      <li><strong>回路控制</strong>：支持显式 while/if，避免模型陷入无意义循环，也能限制最大步数。</li>
      <li><strong>共享状态</strong>：图上所有节点可读写一个全局 state，对话历史、检索结果、缓存都存这里。</li>
    </ul>
    <h3>2. 优势</h3>
    <ol>
      <li><strong>流程透明</strong>：复杂任务拆成节点后，人类能清楚看到“模型现在在哪一步”。</li>
      <li><strong>易于插拔</strong>：想换检索策略、加一个评审环节，只需替换对应节点。</li>
      <li><strong>适配多模型</strong>：某些节点可调用 Claude，另一些调用 GPT 或本地模型，按需分工。</li>
    </ol>
    <h3>3. 典型用法</h3>
    <ul>
      <li>检索增强生成（RAG）流水线：检索→阅读→回答→审核，一目了然。</li>
      <li>运营或风控审批：决策节点可以写成“若分数 &gt; 0.8 则终止，否则转人工”。</li>
      <li>多模态任务：不同节点对接音频、图片、代码分析器。</li>
    </ul>
    <h3>4. 注意事项</h3>
    <p>LangGraph 的威力来自“把复杂度显性化”，代价是需要提前建模。当需求还在快速迭代时，图可能频繁重构。此外，它对新手来说学习曲线比简单 harness 高，需要理解状态机、异步事件等概念。</p>

    <h2>AutoGen：多角色协作的对话剧场</h2>
    <p>微软的 AutoGen 提出了“多 Agent 协作”的范式：你可以定义多个角色（Expert、Critic、UserProxy、ToolServer），让它们按轮次对话、互相验证，再把结论返回给人。它的 harness 核心是对 <em>对话轮换</em> 的控制。</p>
    <h3>1. 运作方式</h3>
    <ul>
      <li><strong>角色脚本</strong>：每个 Agent 有自己的 system prompt、工具权限、终止条件。</li>
      <li><strong>消息路由</strong>：AutoGen 控制谁向谁发话，什么时候由工具代理接手，什么时候停。</li>
      <li><strong>人类插入</strong>：可以在剧场里随时插入人类角色，打断或追加指令。</li>
    </ul>
    <h3>2. 优势</h3>
    <ol>
      <li><strong>自动交叉验证</strong>：让 Critic 复查 Expert 的输出，显著降低幻觉。</li>
      <li><strong>任务分工</strong>：一个 Agent 专注写代码，另一个负责测试，第三个负责汇报。</li>
      <li><strong>脚本化</strong>：把长流程写成“剧本”，便于复用。</li>
    </ol>
    <h3>3. 适合场景</h3>
    <ul>
      <li>需要多轮评审的工作：内容审核、金融报告草稿、法律审阅。</li>
      <li>教学/陪练：让“导师 Agent”对“学生 Agent”提问，模拟课堂。</li>
      <li>要引入人类实时参与的协作：AutoGen 的界面允许随时插入人工回复。</li>
    </ul>
    <h3>4. 局限</h3>
    <p>更多角色意味着更多 token 成本，且剧本越长越容易跑偏。你需要精心设计每个角色的 prompt，防止它们在无关话题上空转。此外，当任务本质上是单人单步的（比如简单脚本），AutoGen 反而显得重。</p>

    <h2>OpenAI Function Calling + ReAct：轻量却万能的经典组合</h2>
    <p>Function Calling 让模型能以结构化 JSON 调用工具，而 ReAct（Reason + Act）提示让模型先写出思考，再决定调用哪一个函数。这套 harness 虽然“朴素”，却极其灵活，适合从零搭建的小团队。</p>
    <h3>1. 运行机制</h3>
    <ul>
      <li><strong>函数声明</strong>：开发者用 JSON Schema 描述可用工具，模型调用时必须按 schema 输出。</li>
      <li><strong>ReAct 模板</strong>：提示模型遵循“Thought → Action → Observation → Thought …”的链条，明确每一步的意图。</li>
      <li><strong>最小状态</strong>：上下文通常只包含对话与少量记忆，逻辑相对轻量。</li>
    </ul>
    <h3>2. 优点</h3>
    <ol>
      <li><strong>实现成本低</strong>：几乎所有语言/框架都有现成 SDK。</li>
      <li><strong>通用性强</strong>：可用在客服机器人、数据库问答、轻量自动化等大量场景。</li>
      <li><strong>可渐进增强</strong>：先用简单函数，逐步扩展更多工具或状态缓存。</li>
    </ol>
    <h3>3. 典型案例</h3>
    <ul>
      <li>客服问答 + 工单创建：模型阅读知识库，必要时调用 <code>create_ticket</code> 函数。</li>
      <li>简易数据管家：查询 SQL、调用 BI 接口，返回图表或摘要。</li>
      <li>个人助理：日历、天气、待办事项都封装成函数，由 ReAct 控制调用顺序。</li>
    </ul>
    <h3>4. 难点</h3>
    <p>因为它轻量，所以大部分工程责任落在开发者身上：需要自己实现记忆、缓存、错误重试、权限控制。若忽略这些，模型在复杂任务里容易迷路。因此 Function Calling + ReAct 更像“积木套件”，需要你有明确的系统设计能力。</p>

    <h2>如何选择适合你的 harness？</h2>
    <p>可以用下面这组问题做决策：</p>
    <ol>
      <li><strong>任务复杂度</strong>：是单人单步（倾向 Claude Code / ReAct），还是多节点、多审阅（倾向 LangGraph / AutoGen）。</li>
      <li><strong>团队成熟度</strong>：有专门平台团队吗？若没有，选择开箱即用的 harness（Claude Code / ReAct）更现实。</li>
      <li><strong>需要多少可视化</strong>：需要流程图、节点监控？LangGraph 天生适合；只要日志？Claude Code 即可。</li>
      <li><strong>对协作的需求</strong>：若想让多个 Agent 或人机同台，AutoGen 是首选。</li>
      <li><strong>监管与审计</strong>：银行、医药等行业喜欢有审计轨迹的 harness；Claude Code 的日志、LangGraph 的状态机都容易满足。</li>
    </ol>

    <h2>自建 harness 的设计清单</h2>
    <p>无论你选择哪种框架，以下十条是我在项目里总结的“必备功能”：</p>
    <ol>
      <li><strong>统一入口提示</strong>：系统提示里明确角色、目标、限制、可用工具。</li>
      <li><strong>结构化日志</strong>：每次工具调用统一格式记录，包含输入参数、输出摘要、耗时。</li>
      <li><strong>可重播性</strong>：能把整个会话重播（含命令和文件快照），方便调试。</li>
      <li><strong>权限隔离</strong>：不同任务/租户的文件与 API key 不混用。</li>
      <li><strong>错误分类</strong>：区分“模型输出错误”“工具执行失败”“权限不足”，给出不同恢复策略。</li>
      <li><strong>速率限制与熔断</strong>：保护外部 API，不让模型在异常循环里打爆配额。</li>
      <li><strong>版本管理</strong>：对提示、工具 schema、依赖库做版本号，便于回滚。</li>
      <li><strong>观测指标</strong>：例如平均步数、成功率、token 花费，拿来优化 prompt 或流程。</li>
      <li><strong>人类逃生舱</strong>：随时允许人类接管，无论是暂停、修改上下文或终止任务。</li>
      <li><strong>可测试性</strong>：为关键提示/流程写自动化测试，确保升级模型或提示后行为稳定。</li>
    </ol>

    <h2>未来趋势：harness 会成为“操作系统”</h2>
    <p>随着模型本身趋近同质化，人们正在竞争的是更聪明的 harness：它能否理解组织的业务语境、能否调用私有工具、能否把人类同事无缝拉进 loop。长远看，一个成熟的 harness 会像“AI 操作系统”——里面接入了 CI/CD、数据仓库、CRM、语音通话甚至机械臂，而模型们只管提出意图。</p>

    <p>所以，当你评估“哪个模型最好”时，别忘了先问：<strong>我的 harness 到底让模型发挥了多少？</strong>如果驾舱还是一堆零散脚本，那再聪明的模型也只能跌跌撞撞。反之，只要 harness 打理得当，哪怕换别的基础模型，也能几乎无缝切换。</p>

    <h2>结语</h2>
    <p>回到最初的问题：“Best harness, best model。”我的答案是：对大多数团队而言，<em>best harness</em> 比 <em>best model</em> 更值得优先设计。Claude Code 让个体开发者获得“一致输出”；LangGraph 带来流程图级别的透明；AutoGen 提供多角色协作的舞台；Function Calling + ReAct 让轻量场景拥有足够的自由度。选一个起点，然后坚持打磨这个驾舱，你就能让同一个模型看起来像换了灵魂。</p>

    <p>下一次有人问“模型为什么这么笨”，不妨先一起检查 harness ——也许真正需要升级的，是那个负责连接世界的座舱。</p>
  </main>
</body>
</html>
