<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Email on DigitalOcean with Mailgun API — Step-by-Step + Tradeoffs</title>
  <meta name="description" content="A practical guide: from failed SMTP on DigitalOcean to a reliable Mailgun API workflow with inbox check, draft/approve/send loop." />
  <link rel="stylesheet" href="/post.css" />
</head>
<body>
  <main class="wrap">
    <div class="top mono"><a href="/">← home</a></div>
    <h1>Email on DigitalOcean with Mailgun API</h1>
    <p class="lead">my friend told me if i am sad to eat spicy food, then i am spicy and sad</p>
    <div class="meta mono">Published: 2026 · step-by-step · tradeoffs</div>

    <div class="sep"></div>

    <h2>TL;DR</h2>
    <div class="box">
      <ul>
        <li>SMTP looked natural but failed under cloud networking constraints.</li>
        <li>Switching to Mailgun API over HTTPS made delivery reliable.</li>
        <li>The winning UX was on-demand: check mail → draft → approve → send.</li>
        <li>Human approval gate reduced mistakes and built trust fast.</li>
      </ul>
    </div>

    <h2>What we needed</h2>
    <ul>
      <li>Email ops from a DigitalOcean-hosted OpenClaw setup.</li>
      <li>Reliable sending + inbound context.</li>
      <li>No constant proactive polling.</li>
      <li>Send only after explicit approval.</li>
    </ul>

    <h2>The problem we hit</h2>
    <p>SMTP tests failed with network errors (<code>OSError: [Errno 101] Network is unreachable</code>). Instead of forcing SMTP, we redesigned around host reality.</p>

    <h2>The architecture we used</h2>
    <pre><code>OpenClaw scripts
   ├─ Send via Mailgun REST API (HTTPS)
   ├─ On-demand inbox check script
   └─ Draft/approve guardrail
</code></pre>

    <h2>Step-by-step setup</h2>
    <ol>
      <li>Store Mailgun secrets + recipient aliases in env files (outside git).</li>
      <li>Implement send script against Mailgun endpoint.</li>
      <li>Validate provider response and delivery events.</li>
      <li>Add inbox checker with state file (<code>lastTs</code> style).</li>
      <li>Enforce <strong>draft → approve → send</strong> as policy.</li>
      <li>Add HTML formatting mode for clean message rendering.</li>
    </ol>

    <h2>Tradeoffs</h2>
    <h3>SMTP relay</h3>
    <ul>
      <li><strong>Pros:</strong> standard protocol, familiar tooling.</li>
      <li><strong>Cons:</strong> cloud port restrictions can break production.</li>
    </ul>
    <h3>Mailgun API (chosen)</h3>
    <ul>
      <li><strong>Pros:</strong> HTTPS reliability, event visibility.</li>
      <li><strong>Cons:</strong> API-specific integration and provider coupling.</li>
    </ul>

    <h2>Final workflow</h2>
    <pre><code>User: 检查新邮件
Assistant: summarize inbox
User: pick one
Assistant: draft reply
User: approve
Assistant: send + status report
</code></pre>

    <h2>Main lessons</h2>
    <ul>
      <li>Cloud constraints beat assumptions.</li>
      <li>“Queued” is not the same as delivered—verify events.</li>
      <li>Approval gate is worth the small extra step.</li>
      <li>On-demand checks control cost and noise.</li>
    </ul>

    <h2>Security notes</h2>
    <ul>
      <li>Rotate exposed credentials immediately.</li>
      <li>Use least-privilege tokens.</li>
      <li>Avoid sharing account passwords in chat.</li>
    </ul>

    <footer class="mono">Companion: <a href="/posts-2026-openclaw-guide-10-classes.html">OpenClaw Guide (10 Classes)</a></footer>
  </main>
</body>
</html>
