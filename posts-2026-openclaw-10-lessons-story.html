<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>From Zero to OpenClaw: 10 Lessons, One Real Build Story</title>
  <meta name="description" content="A human-style, step-by-step story of building a practical OpenClaw setup: decisions, mistakes, tradeoffs, and what actually worked." />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0a0b10;--fg:#edf1f7;--muted:#9aa4b5;--line:#1b2230;--accent:#86d6ff;--max:840px}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.78}
    .wrap{max-width:var(--max);margin:0 auto;padding:50px 22px 80px}
    .mono{font-family:"IBM Plex Mono",ui-monospace,SFMono-Regular,Menlo,monospace}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    h1{font-size:clamp(30px,5.2vw,54px);line-height:1.08;letter-spacing:-.02em;margin:10px 0 14px}
    h2{margin-top:36px;font-size:26px;letter-spacing:-.01em}
    h3{margin-top:26px;font-size:20px}
    .top,.meta{color:var(--muted);font-size:13px}
    .lead{font-size:20px;color:#c1cbdb;max-width:48ch}
    .box{border:1px solid var(--line);background:#0e141f;border-radius:12px;padding:14px 16px}
    .sep{height:1px;background:var(--line);margin:28px 0}
    code{font-family:"IBM Plex Mono",ui-monospace,SFMono-Regular,Menlo,monospace;background:#141b28;border:1px solid #273147;padding:1px 5px;border-radius:6px}
    pre{overflow:auto;background:#0f1623;border:1px solid #2b3750;border-radius:10px;padding:12px;font-size:13px;line-height:1.55}
    ul,ol{padding-left:22px}
    blockquote{margin:16px 0;padding:10px 14px;border-left:3px solid #33425e;background:#0d1320;border-radius:8px;color:#c8d2e4}
    .kicker{font-size:12px;letter-spacing:.1em;text-transform:uppercase;color:var(--accent)}
  </style>
</head>
<body>
  <main class="wrap">
    <div class="top mono"><a href="/">← home</a></div>
    <h1>From Zero to OpenClaw: 10 Lessons, One Real Build Story</h1>
    <p class="lead">This is not a polished demo. It’s the real build log: what we needed, what broke, what we changed, and why the final setup is practical.</p>
    <div class="meta mono">Published: 2026 · ~12 min read · storytelling + step-by-step</div>

    <div class="sep"></div>

    <div class="kicker mono">Outlet (TL;DR first)</div>
    <div class="box">
      <ol>
        <li><strong>Start from user workflow, not tool hype.</strong> Our goal was clear: reliable email operations with human approval.</li>
        <li><strong>Infrastructure reality matters.</strong> SMTP looked obvious, but cloud restrictions forced a better architecture (Mailgun API over HTTPS).</li>
        <li><strong>Guardrails beat “full automation”.</strong> Manual check + draft + explicit approve gave trust, lower cost, and fewer mistakes.</li>
        <li><strong>OpenClaw power comes from composition.</strong> Sessions + scripts + memory + cron + policies turned into a real system, not just chat.</li>
        <li><strong>Ship in thin slices.</strong> We kept momentum by solving one bottleneck at a time, then only polishing what was proven useful.</li>
      </ol>
    </div>

    <h2>How to read this: the onion model</h2>
    <p>We’ll peel this like an onion:</p>
    <ul>
      <li><strong>Layer 1:</strong> Big frame & requirements</li>
      <li><strong>Layer 2:</strong> What we built (the 10 lessons)</li>
      <li><strong>Layer 3:</strong> Questions that changed direction mid-way</li>
      <li><strong>Layer 4:</strong> Final architecture and operating playbook</li>
    </ul>

    <pre><code>Need → Constraints → Failed path → Better path → Guardrails → Stable workflow</code></pre>

    <h2>Layer 1 — Big frame: what we were actually trying to do</h2>
    <p>At the start, the mission sounded broad: “let’s build a practical OpenClaw setup and learn components step by step.”
    But operationally, one thread became dominant: <strong>email that works from a DigitalOcean-hosted environment</strong>.</p>

    <p>The requirements became very concrete:</p>
    <ul>
      <li>Must work on cloud host without brittle hacks.</li>
      <li>Must support both sending and reading inbound context.</li>
      <li>No noisy autopilot polling; user wanted <strong>on-demand checks</strong>.</li>
      <li>No blind sends. Every outgoing reply should pass <strong>human approval</strong>.</li>
      <li>Prefer low-cost, low-maintenance path.</li>
    </ul>

    <blockquote>
      The most important architectural choice was social, not technical:
      “assistant drafts, human approves, then send.”
    </blockquote>

    <h2>Layer 2 — The 10 lessons (what we learned building for real)</h2>

    <h3>Lesson 1 — Identity and context are not cosmetics</h3>
    <p>We set up identity/profile files early (<code>IDENTITY.md</code>, <code>USER.md</code>, memory notes, tone preferences).
    It looked like small stuff, but it stabilized output quality and reduced back-and-forth.
    Short Telegram-friendly mixed CN/EN style, timezone awareness, and signature preferences all mattered later.</p>

    <h3>Lesson 2 — Instrumentation beats vibes</h3>
    <p>Before scaling usage, we added reporting scripts (token/cost summaries).
    This changed the conversation from “feels expensive” to measurable operation.</p>

    <h3>Lesson 3 — Cloud networking kills naive SMTP plans</h3>
    <p>We tried SMTP first (natural choice), then hit:</p>
    <pre><code>OSError: [Errno 101] Network is unreachable</code></pre>
    <p>This was not a random bug; it was environment policy reality (common SMTP port restrictions on cloud hosts).
    We stopped forcing the wrong abstraction.</p>

    <h3>Lesson 4 — API over HTTPS is often the practical production path</h3>
    <p>Switching to Mailgun API (<code>https://api.mailgun.net</code>) gave immediate reliability on 443.
    Send responses became deterministic (<code>Queued. Thank you.</code>), and delivery events gave objective confirmation.</p>

    <h3>Lesson 5 — “Queued” is not success. Delivery events are.</h3>
    <p>A lot of teams stop too early. We explicitly verified delivered events to target addresses.
    That saved us from false-positive “it works” claims.</p>

    <h3>Lesson 6 — On-demand inbox checks are a design choice, not a compromise</h3>
    <p>Instead of aggressive polling, we built a manual trigger script with incremental state.
    Result: fewer tokens burned, less noise, better timing control.</p>

    <h3>Lesson 7 — Approval gate is a trust multiplier</h3>
    <p>The workflow became:</p>
    <pre><code>Check mail → summarize → user selects → assistant drafts → user approves → send</code></pre>
    <p>This reduced anxiety and made automation feel safe and professional.</p>

    <h3>Lesson 8 — Formatting is not superficial in communication systems</h3>
    <p>We observed plain-text newline/render issues in real outbound messages.
    So we introduced HTML-formatted paths for nicer, consistent reading experiences.</p>

    <h3>Lesson 9 — Not every track should be pushed to completion immediately</h3>
    <p>Parallel browser-control troubleshooting (Track A) was unstable (timeouts, token mismatch history).
    Instead of burning cycles endlessly, we deprioritized it and shipped the email path first.
    That was a good product decision.</p>

    <h3>Lesson 10 — Build systems with reversible credentials, not shared passwords</h3>
    <p>During GitHub deployment work, a key security pattern appeared again:
    use scoped, revocable PATs rather than account passwords in chat.
    Operational speed and security can coexist if permission boundaries are tight.</p>

    <h2>Layer 3 — Mid-course questions that changed the plan</h2>
    <p>Some of the most useful moments were short user questions that forced clarity:</p>
    <ul>
      <li><strong>“Repo 建在我个人账号下吗？”</strong> → yes, ownership and URL strategy first.</li>
      <li><strong>“token 发这 chat 么？”</strong> → practical yes, but with least privilege + immediate revoke guidance.</li>
      <li><strong>“你能自己 own 账号吗？”</strong> → clarified trust boundaries: avoid password sharing, prefer revocable tokens.</li>
      <li><strong>“学习一下某个网站风格”</strong> → moved from raw deployment to design language and editorial tone.</li>
      <li><strong>“placeholder posts can go”</strong> → quality over filler content.</li>
    </ul>

    <p>These weren’t random chat lines. They were product requirements in disguise.</p>

    <h2>Layer 4 — Final operating architecture</h2>
    <pre><code>[User Intent]
   ↓
[OpenClaw Session]
   ↓
[Scripts + Memory + Guardrails]
   ├─ Mailgun Send API (HTTPS)
   ├─ Manual Inbox Check Script
   ├─ Draft/Approve Policy
   └─ Optional Cron/Reporting
   ↓
[Reliable Human-in-the-loop Email Ops]</code></pre>

    <h3>Why this architecture worked</h3>
    <ul>
      <li>Environment-compatible transport (HTTPS over blocked SMTP).</li>
      <li>State-aware scripts (incremental checks).</li>
      <li>Human decision point before irreversible action.</li>
      <li>Measured operation (cost/reporting), not guesswork.</li>
    </ul>

    <h2>Step-by-step playbook (if you want to reproduce this)</h2>
    <ol>
      <li>Write exact communication workflow first (who approves what).</li>
      <li>Validate host network constraints before picking transport.</li>
      <li>If SMTP is fragile, switch to provider API over HTTPS.</li>
      <li>Implement send + delivery verification (not just queue response).</li>
      <li>Implement inbound check as explicit command with state file.</li>
      <li>Add draft/approve gate as policy, not optional behavior.</li>
      <li>Only then optimize formatting, templates, and UX polish.</li>
      <li>Keep credentials scoped + revocable; rotate exposed secrets.</li>
    </ol>

    <h2>The tradeoffs (explicitly)</h2>

    <h3>Why not full autonomy?</h3>
    <ul>
      <li><strong>Pro of autonomy:</strong> faster throughput.</li>
      <li><strong>Con:</strong> higher communication risk, less trust.</li>
    </ul>
    <p>For personal/professional email, we chose trust and correctness.</p>

    <h3>Why not “finish browser automation first”?</h3>
    <ul>
      <li><strong>Pro:</strong> larger long-term capability.</li>
      <li><strong>Con:</strong> unstable dependencies can block immediate value.</li>
    </ul>
    <p>We shipped reliable email first because it solved an urgent real need.</p>

    <h2>What this says about OpenClaw itself</h2>
    <p>OpenClaw’s strength is not one super feature. It’s orchestration:
    memory + tools + scripts + policy + iterative user feedback.
    Once those pieces align, it stops being “chat with commands” and becomes a working system.</p>

    <h2>Closing: what changed by the end</h2>
    <p>At the beginning, this looked like “teach me 10 parts of OpenClaw.”
    By the end, it became something better: a deployable practice.</p>

    <ul>
      <li>We moved from assumptions to constraints-aware architecture.</li>
      <li>From “can send email?” to “can operate email safely every day?”</li>
      <li>From one-off commands to a repeatable runbook.</li>
    </ul>

    <blockquote>
      Real automation maturity is when your workflow is boring—in the best possible way.
    </blockquote>

    <div class="sep"></div>
    <p class="meta mono">Companion post: <a href="/posts-2026-email-do-mailgun.html">Email on DigitalOcean with Mailgun API</a></p>
  </main>
</body>
</html>
